{"ast":null,"code":"import { io } from 'socket.io-client';\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n  }\n  connect() {\n    const wsUrl = process.env.REACT_APP_WS_URL || 'http://localhost:5000';\n    this.socket = io(wsUrl, {\n      transports: ['websocket'],\n      autoConnect: true\n    });\n    this.socket.on('connect', () => {\n      console.log('WebSocket connected');\n      this.reconnectAttempts = 0;\n    });\n    this.socket.on('disconnect', () => {\n      console.log('WebSocket disconnected');\n      this.handleReconnect();\n    });\n    this.socket.on('connect_error', error => {\n      console.error('WebSocket connection error:', error);\n      this.handleReconnect();\n    });\n  }\n  handleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      setTimeout(() => {\n        var _this$socket;\n        console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.connect();\n      }, 2000 * this.reconnectAttempts);\n    }\n  }\n  subscribeToNodeUpdates(callback) {\n    if (!this.socket) return;\n    this.socket.emit('subscribe_nodes');\n    this.socket.on('node_status_changed', callback);\n  }\n  subscribeToClusterUpdates(clusterId, callback) {\n    if (!this.socket) return;\n    this.socket.emit('subscribe_cluster', {\n      cluster_id: clusterId\n    });\n    this.socket.on('cluster_metrics_updated', callback);\n  }\n  unsubscribeFromNodeUpdates() {\n    if (!this.socket) return;\n    this.socket.off('node_status_changed');\n  }\n  unsubscribeFromClusterUpdates() {\n    if (!this.socket) return;\n    this.socket.off('cluster_metrics_updated');\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n  }\n  isConnected() {\n    var _this$socket2;\n    return ((_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.connected) || false;\n  }\n}\nexport const wsService = new WebSocketService();\nexport default wsService;","map":{"version":3,"names":["io","WebSocketService","constructor","socket","reconnectAttempts","maxReconnectAttempts","connect","wsUrl","process","env","REACT_APP_WS_URL","transports","autoConnect","on","console","log","handleReconnect","error","setTimeout","_this$socket","subscribeToNodeUpdates","callback","emit","subscribeToClusterUpdates","clusterId","cluster_id","unsubscribeFromNodeUpdates","off","unsubscribeFromClusterUpdates","disconnect","isConnected","_this$socket2","connected","wsService"],"sources":["/Users/ashutosh/zansoc-beta/frontend/src/services/websocket.ts"],"sourcesContent":["import { io, Socket } from 'socket.io-client';\nimport { Node, ActiveCluster } from '../types';\n\nclass WebSocketService {\n  private socket: Socket | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n\n  connect(): void {\n    const wsUrl = process.env.REACT_APP_WS_URL || 'http://localhost:5000';\n    \n    this.socket = io(wsUrl, {\n      transports: ['websocket'],\n      autoConnect: true,\n    });\n\n    this.socket.on('connect', () => {\n      console.log('WebSocket connected');\n      this.reconnectAttempts = 0;\n    });\n\n    this.socket.on('disconnect', () => {\n      console.log('WebSocket disconnected');\n      this.handleReconnect();\n    });\n\n    this.socket.on('connect_error', (error) => {\n      console.error('WebSocket connection error:', error);\n      this.handleReconnect();\n    });\n  }\n\n  private handleReconnect(): void {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      setTimeout(() => {\n        console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        this.socket?.connect();\n      }, 2000 * this.reconnectAttempts);\n    }\n  }\n\n  subscribeToNodeUpdates(callback: (nodes: Node[]) => void): void {\n    if (!this.socket) return;\n    \n    this.socket.emit('subscribe_nodes');\n    this.socket.on('node_status_changed', callback);\n  }\n\n  subscribeToClusterUpdates(clusterId: string, callback: (cluster: ActiveCluster) => void): void {\n    if (!this.socket) return;\n    \n    this.socket.emit('subscribe_cluster', { cluster_id: clusterId });\n    this.socket.on('cluster_metrics_updated', callback);\n  }\n\n  unsubscribeFromNodeUpdates(): void {\n    if (!this.socket) return;\n    this.socket.off('node_status_changed');\n  }\n\n  unsubscribeFromClusterUpdates(): void {\n    if (!this.socket) return;\n    this.socket.off('cluster_metrics_updated');\n  }\n\n  disconnect(): void {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n  }\n\n  isConnected(): boolean {\n    return this.socket?.connected || false;\n  }\n}\n\nexport const wsService = new WebSocketService();\nexport default wsService;"],"mappings":"AAAA,SAASA,EAAE,QAAgB,kBAAkB;AAG7C,MAAMC,gBAAgB,CAAC;EAAAC,YAAA;IAAA,KACbC,MAAM,GAAkB,IAAI;IAAA,KAC5BC,iBAAiB,GAAG,CAAC;IAAA,KACrBC,oBAAoB,GAAG,CAAC;EAAA;EAEhCC,OAAOA,CAAA,EAAS;IACd,MAAMC,KAAK,GAAGC,OAAO,CAACC,GAAG,CAACC,gBAAgB,IAAI,uBAAuB;IAErE,IAAI,CAACP,MAAM,GAAGH,EAAE,CAACO,KAAK,EAAE;MACtBI,UAAU,EAAE,CAAC,WAAW,CAAC;MACzBC,WAAW,EAAE;IACf,CAAC,CAAC;IAEF,IAAI,CAACT,MAAM,CAACU,EAAE,CAAC,SAAS,EAAE,MAAM;MAC9BC,OAAO,CAACC,GAAG,CAAC,qBAAqB,CAAC;MAClC,IAAI,CAACX,iBAAiB,GAAG,CAAC;IAC5B,CAAC,CAAC;IAEF,IAAI,CAACD,MAAM,CAACU,EAAE,CAAC,YAAY,EAAE,MAAM;MACjCC,OAAO,CAACC,GAAG,CAAC,wBAAwB,CAAC;MACrC,IAAI,CAACC,eAAe,CAAC,CAAC;IACxB,CAAC,CAAC;IAEF,IAAI,CAACb,MAAM,CAACU,EAAE,CAAC,eAAe,EAAGI,KAAK,IAAK;MACzCH,OAAO,CAACG,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;MACnD,IAAI,CAACD,eAAe,CAAC,CAAC;IACxB,CAAC,CAAC;EACJ;EAEQA,eAAeA,CAAA,EAAS;IAC9B,IAAI,IAAI,CAACZ,iBAAiB,GAAG,IAAI,CAACC,oBAAoB,EAAE;MACtD,IAAI,CAACD,iBAAiB,EAAE;MACxBc,UAAU,CAAC,MAAM;QAAA,IAAAC,YAAA;QACfL,OAAO,CAACC,GAAG,CAAC,+BAA+B,IAAI,CAACX,iBAAiB,IAAI,IAAI,CAACC,oBAAoB,GAAG,CAAC;QAClG,CAAAc,YAAA,OAAI,CAAChB,MAAM,cAAAgB,YAAA,uBAAXA,YAAA,CAAab,OAAO,CAAC,CAAC;MACxB,CAAC,EAAE,IAAI,GAAG,IAAI,CAACF,iBAAiB,CAAC;IACnC;EACF;EAEAgB,sBAAsBA,CAACC,QAAiC,EAAQ;IAC9D,IAAI,CAAC,IAAI,CAAClB,MAAM,EAAE;IAElB,IAAI,CAACA,MAAM,CAACmB,IAAI,CAAC,iBAAiB,CAAC;IACnC,IAAI,CAACnB,MAAM,CAACU,EAAE,CAAC,qBAAqB,EAAEQ,QAAQ,CAAC;EACjD;EAEAE,yBAAyBA,CAACC,SAAiB,EAAEH,QAA0C,EAAQ;IAC7F,IAAI,CAAC,IAAI,CAAClB,MAAM,EAAE;IAElB,IAAI,CAACA,MAAM,CAACmB,IAAI,CAAC,mBAAmB,EAAE;MAAEG,UAAU,EAAED;IAAU,CAAC,CAAC;IAChE,IAAI,CAACrB,MAAM,CAACU,EAAE,CAAC,yBAAyB,EAAEQ,QAAQ,CAAC;EACrD;EAEAK,0BAA0BA,CAAA,EAAS;IACjC,IAAI,CAAC,IAAI,CAACvB,MAAM,EAAE;IAClB,IAAI,CAACA,MAAM,CAACwB,GAAG,CAAC,qBAAqB,CAAC;EACxC;EAEAC,6BAA6BA,CAAA,EAAS;IACpC,IAAI,CAAC,IAAI,CAACzB,MAAM,EAAE;IAClB,IAAI,CAACA,MAAM,CAACwB,GAAG,CAAC,yBAAyB,CAAC;EAC5C;EAEAE,UAAUA,CAAA,EAAS;IACjB,IAAI,IAAI,CAAC1B,MAAM,EAAE;MACf,IAAI,CAACA,MAAM,CAAC0B,UAAU,CAAC,CAAC;MACxB,IAAI,CAAC1B,MAAM,GAAG,IAAI;IACpB;EACF;EAEA2B,WAAWA,CAAA,EAAY;IAAA,IAAAC,aAAA;IACrB,OAAO,EAAAA,aAAA,OAAI,CAAC5B,MAAM,cAAA4B,aAAA,uBAAXA,aAAA,CAAaC,SAAS,KAAI,KAAK;EACxC;AACF;AAEA,OAAO,MAAMC,SAAS,GAAG,IAAIhC,gBAAgB,CAAC,CAAC;AAC/C,eAAegC,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}